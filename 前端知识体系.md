# JavaScript 基础知识梳理（上）

## 目录

1. **[数据类型](#数据类型)**
1. **[类型转换](#类型转换)**
1. **[类型判断](#类型判断)**
1. **[作用域, 调用堆栈, 闭包](#作用域-调用堆栈-闭包)**
1. **[this, call, apply 和 bind](#this-call-apply-和-bind)**
1. **[原型继承与原型链](#原型继承与原型链)**
1. **[map, reduce, filter 等高阶函数](#map-reduce-filter-等高阶函数)**
1. **[偏函数, 柯里化, 惰性函数, 函数组合, 函数记忆](#偏函数-柯里化-惰性函数-函数组合-函数记忆)**
1. **[异步](#异步)**
1. **[消息队列和事件循环](#消息队列和事件循环)**
1. **[模块化](#模块化)**
1. **[设计模式](#设计模式)**

## 数据类型

### 值类型和引用类型

值类型：字符串（string）、数值（number）、布尔值（boolean）、undefined、null、symbol、bigInt

> 值类型保存在栈中，值类型赋值之后两个变量互不影响

```js
let foo = 1
let bar = foo

bar = 2
console.log(foo, bar) // 1, 2
```

引用类型：对象（Object）、数组（Array）、函数（Function）...

> 引用类型保存在堆中，栈中保存的是引用类型的指针，引用类型赋值之后，两个变量具有相同的引用，指向同一个对象，相互之间有影响

```js
let o1 = { a: 1, b: 2 }
var o2 = o1

o2.a = 2

console.log(o1, o2) // { a: 2, b: 2 }, { a: 2, b: 2 }
```

### 函数参数按值传递

> 在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量
>
> 在向参数传递引用类型的值时，会把这个引用类型的地址复制给一个局部变量，因此在函数内部修改参数，将会影响到原始值

```js
function test(person) {
	person.name = 'chu'
	person = { name: 'bar', age: 18 }
	return person
}
const p1 = { name: 'foo', age: 25 }
const p2 = test(p1)
console.log(p1) // -> { name: 'chu', age: 25 }
console.log(p2) // -> { name: 'bar', age: 18 }
```

## 类型转换

### 转换成布尔值

在 JavaScript 中，只有 7 种值可以被转换成 false，其他都会被转换成 true。

```js
console.log(Boolean(false)) // false

console.log(Boolean(undefined)) // false
console.log(Boolean(null)) // false
console.log(Boolean(+0)) // false
console.log(Boolean(-0)) // false
console.log(Boolean(NaN)) // false
console.log(Boolean('')) // false
console.log(Boolean(0n)) // false
```

### 转换成数字

```js
console.log(Number('')) // 0
console.log(Number(undefined)) // NaN
console.log(Number(null)) // 0
```

### 转换成字符串

```js
console.log(String([]) === '')
```

### 转换成 JSON

```js
const obj = {
	toJSON() {
		return 'hello world'
	},
}

console.log(JSON.stringify(obj)) // "hello world"
```

## 原始类型与实例对象的自动转换

```js
console.log('hello world'.length) // 11
```

> 上面代码中，`'hello world'` 是一个字符串，本身不是对象，不能调用 length 属性。
>
> JavaScript 引擎自动将其转为包装对象，在这个对象上调用 length 属性。
>
> 调用结束后，这个临时对象就会被销毁。这就叫原始类型与实例对象的自动转换。

### 对象转换成原始类型

```js
const obj = {
	value: 3,
	valueOf: () => 4,
	toString: () => '5',
	[Symbol.toPrimitive]: () => 6,
}
```

- 三者都存在，转换成原始类型会优先调用 `[Symbol.toPrimitive]` 的返回值。

  ```js
  console.log(String(obj)) // '6'
  console.log(Number(obj)) // 6
  ```

- `[Symbol.toPrimitive]` 不存在，`String` 会调用 `toString`，`Number` 会调用 `valueOf`。

  ```js
  console.log(String(obj)) // '5'
  console.log(Number(obj)) // 4
  ```

- 只有 `toString` 存在，`String` 会调用 `toString`，`Number` 也会调用 `toString`，然后会使用 `Number` 把字符串转换成数字。

  ```js
  console.log(String(obj)) // '5'
  console.log(Number(obj)) // 5
  ```

- 只有 `valueOf` 存在，`Number` 会调用 `valueOf`，`String` 会调用 `Object.prototype.toString`

  ```js
  console.log(String(obj)) // '[object Object]'
  console.log(Number(obj)) // 4
  ```

- 都不存在，`String` 会调用 `Object.prototype.toString`，`Number` 也会调用 `Object.prototype.toString`，然后会使用 `Number` 把字符串转换成数字。

  ```js
  console.log(String(obj)) // '[object Object]'
  console.log(Number(obj)) // NaN
  ```

### 面试题：如何让 `if(a == 1 && a == 2)` 条件成立？

解法一：

```js
const a = {
	i: 1,
	toString() {
		return this.i++
	},
}
if (a == 1 && a == 2 && a == 3) {
	console.log('success')
}
```

解法二：

```js
const a = {
	i: [1, 2, 3],
	valueOf() {
		return this.i.shift()
	},
}
if (a == 1 && a == 2 && a == 3) {
	console.log('success')
}
```

解法三：

```js
window.val = 1
Object.defineProperty(window, 'a', {
	get: () => this.val++,
})

if (a == 1 && a == 2 && a == 3) {
	console.log('success')
}
```

### 面试题：为什么 `['1', '2', '3'].map(parseInt)` 返回 `[1,NaN,NaN]` ？

- parseInt 方法用于将字符串转为整数。
- parseInt 的参数不是字符串，会先转为字符串再转换。
- parseInt 方法还可以接受第二个参数（2 到 36 之间），如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在 2 到 36 之间，才能得到有意义的结果，超出这个范围，则返回 NaN。如果第二个参数是 `0`、`undefined` 和 `null`，则直接忽略。
- 二进制只能转换含有'0'、'1'的字符串，其他进制也类似。
- parseInt 的返回值只有两种可能，要么是一个十进制整数，要么是 NaN。

## 类型判断

### typeof

```js
console.log(typeof null) // 'object'
console.log(typeof Array.isArray) // 'function'
console.log(typeof typeof Array.isArray) // 'string'
```

### instanceof

```js
function myInstanceof(left, right) {
	//基本数据类型直接返回false
	if (typeof left !== 'object' || left === null) return false
	//getProtypeOf 是 Object 对象自带的一个方法，相当于 xxx.__proto__
	let proto = Object.getPrototypeOf(left)
	while (true) {
		//查找到尽头，还没找到
		if (proto === null) return false
		//找到相同的原型对象
		if (proto === right.prototype) return true
		proto = Object.getPrototypeOf(proto)
	}
}

console.log(myInstanceof(Number(1), Number)) // false
console.log(myInstanceof(new Date(), Date)) // true
```

### Object.prototype.toString

```js

```

### isEmptyObject

### isInt

### isPromise

### Object.is() Array.isArray() Number.is

## 作用域, 闭包

xxx
xx

## call, apply 和 bind

## 原型与原型链

xxx

## 异步编程
