# JavaScript 基础知识梳理（上）

## 目录

1. **[数据类型](#数据类型)**
1. **[类型转换](#类型转换)**
1. **[类型判断](#类型判断)**
1. **[作用域, 调用堆栈, 闭包](#作用域-调用堆栈-闭包)**
1. **[this, call, apply 和 bind](#this-call-apply-和-bind)**
1. **[原型继承与原型链](#原型继承与原型链)**
1. **[map, reduce, filter 等高阶函数](#map-reduce-filter-等高阶函数)**
1. **[偏函数, 柯里化, 惰性函数, 函数组合, 函数记忆](#偏函数-柯里化-惰性函数-函数组合-函数记忆)**
1. **[异步](#异步)**
1. **[消息队列和事件循环](#消息队列和事件循环)**
1. **[模块化](#模块化)**
1. **[设计模式](#设计模式)**

## 数据类型

### 值类型和引用类型

值类型：字符串（string）、数值（number）、布尔值（boolean）、undefined、null、symbol、bigInt

> 值类型保存在栈中，值类型赋值之后两个变量互不影响

```js
let foo = 1
let bar = foo

bar = 2
console.log(foo, bar) // 1, 2
```

引用类型：对象（Object）、数组（Array）、函数（Function）...

> 引用类型保存在堆中，栈中保存的是引用类型的指针，引用类型赋值之后，两个变量具有相同的引用，指向同一个对象，相互之间有影响

```js
let o1 = { a: 1, b: 2 }
var o2 = o1

o2.a = 2

console.log(o1, o2) // { a: 2, b: 2 }, { a: 2, b: 2 }
```

### 函数参数按值传递

> 在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量
>
> 在向参数传递引用类型的值时，会把这个引用类型的地址复制给一个局部变量，因此在函数内部修改参数，将会影响到原始值

```js
function test(person) {
	person.name = 'chu'
	person = { name: 'bar', age: 18 }
	return person
}
const p1 = { name: 'foo', age: 25 }
const p2 = test(p1)
console.log(p1) // -> { name: 'chu', age: 25 }
console.log(p2) // -> { name: 'bar', age: 18 }
```

## 类型转换

### 转换成布尔值

在 JavaScript 中，只有 7 种值可以被转换成 false，其他都会被转换成 true。

```js
console.log(Boolean(false)) // false

console.log(Boolean(undefined)) // false
console.log(Boolean(null)) // false
console.log(Boolean(+0)) // false
console.log(Boolean(-0)) // false
console.log(Boolean(NaN)) // false
console.log(Boolean('')) // false
console.log(Boolean(0n)) // false
```

### 转换成数字

```js
console.log(Number('')) // 0
console.log(Number(undefined)) // NaN
console.log(Number(null)) // 0
console.log(Number([])) // 0
console.log(Number([1, 2, 3])) // NaN
```

### 转换成字符串

```js
console.log(String([]) === '') // true
```

### 转换成 JSON

```js
const obj = {
	toJSON() {
		return 'hello world'
	},
}

console.log(JSON.stringify(obj)) // "hello world"
```

## 原始类型与实例对象的自动转换

```js
console.log('hello world'.length) // 11
```

> 上面代码中，`'hello world'` 是一个字符串，本身不是对象，不能调用 length 属性。
>
> JavaScript 引擎自动将其转为包装对象，在这个对象上调用 length 属性。
>
> 调用结束后，这个临时对象就会被销毁。这就叫原始类型与实例对象的自动转换。

### 对象转换成原始类型

```js
const obj = {
	value: 3,
	valueOf: () => 4,
	toString: () => '5',
	[Symbol.toPrimitive]: () => 6,
}
```

- 三者都存在，转换成原始类型会优先调用 `[Symbol.toPrimitive]` 的返回值。

  ```js
  console.log(String(obj)) // '6'
  console.log(Number(obj)) // 6
  ```

- `[Symbol.toPrimitive]` 不存在，`String` 会调用 `toString`，`Number` 会调用 `valueOf`。

  ```js
  console.log(String(obj)) // '5'
  console.log(Number(obj)) // 4
  ```

- 只有 `toString` 存在，`String` 会调用 `toString`，`Number` 也会调用 `toString`，然后会使用 `Number` 把字符串转换成数字。

  ```js
  console.log(String(obj)) // '5'
  console.log(Number(obj)) // 5
  ```

- 只有 `valueOf` 存在，`Number` 会调用 `valueOf`，`String` 会调用 `Object.prototype.toString`

  ```js
  console.log(String(obj)) // '[object Object]'
  console.log(Number(obj)) // 4
  ```

- 都不存在，`String` 会调用 `Object.prototype.toString`，`Number` 也会调用 `Object.prototype.toString`，然后会使用 `Number` 把字符串转换成数字。

  ```js
  console.log(String(obj)) // '[object Object]'
  console.log(Number(obj)) // NaN
  ```

### 面试题：如何让 `if(a == 1 && a == 2 && a == 3)` 条件成立？

解法一：

```js
const a = {
	i: 1,
	toString() {
		return this.i++
	},
}
if (a == 1 && a == 2 && a == 3) {
	console.log('success')
}
```

解法二：

```js
const a = {
	i: [1, 2, 3],
	valueOf() {
		return this.i.shift()
	},
}
if (a == 1 && a == 2 && a == 3) {
	console.log('success')
}
```

解法三：`===` 也行

```js
window.val = 1
Object.defineProperty(window, 'a', {
	get: () => this.val++,
})

if (a == 1 && a == 2 && a == 3) {
	console.log('success')
}
```

### 面试题：为什么 `['1', '2', '3'].map(parseInt)` 返回 `[1,NaN,NaN]` ？

- parseInt 方法用于将字符串转为整数。
- parseInt 的参数不是字符串，会先转为字符串再转换。
- parseInt 方法还可以接受第二个参数（2 到 36 之间），如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在 2 到 36 之间，才能得到有意义的结果，超出这个范围，则返回 NaN。如果第二个参数是 `0`、`undefined` 和 `null`，则直接忽略。
- 二进制只能转换含有'0'、'1'的字符串，其他进制也类似。
- parseInt 的返回值只有两种可能，要么是一个十进制整数，要么是 NaN。

### 面试题：请实现一个 add 函数，满足以下功能。

分析：链式调用的实现？链式操作，操作返回自身

小试牛刀：

```js
add(1); 	// 1
add(1)(2);  	// 3
add(1)(2)(3)；  // 6
```

实现：

```js
const add = (sum) => {
	const fn = (n) => add(n + sum)
	fn.valueOf = () => sum
	return fn
}

console.log(+add(1)) // 1
console.log(+add(1)(2)) // 3
console.log(+add(1)(2)(3)) // 6
```

扩展：

```
add(1)(2, 3);   // 6
add(1, 2)(3);   // 6
add(1, 2, 3);   // 6
```

```js
const add = (...sums) => {
	sums = sums.reduce((acc, cur) => acc + cur)
	const fn = (...args) => {
		args = args.reduce((acc, cur) => acc + cur)
		return add(sums + args)
	}
	fn.valueOf = () => sums
	return fn
}

console.log(+add(1)(2, 3)) // 6
console.log(+add(1, 2)(3)) // 6
console.log(+add(1, 2, 3)) // 6
```

## 类型判断

### typeof

```js
console.log(typeof null) // 'object'
console.log(typeof Array.isArray) // 'function'
console.log(typeof typeof Array.isArray) // 'string'
```

### instanceof

```js
function myInstanceof(left, right) {
	//基本数据类型直接返回false
	if (typeof left !== 'object' || left === null) return false
	//getProtypeOf 是 Object 对象自带的一个方法，相当于 xxx.__proto__
	let proto = Object.getPrototypeOf(left)
	while (true) {
		//查找到尽头，还没找到
		if (proto === null) return false
		//找到相同的原型对象
		if (proto === right.prototype) return true
		proto = Object.getPrototypeOf(proto)
	}
}

console.log(myInstanceof(Number(1), Number)) // false
console.log(myInstanceof(new Date(), Date)) // true
```

### Object.prototype.toString

```js
Object.prototype.toString.call(2) // "[object Number]"
Object.prototype.toString.call('') // "[object String]"
Object.prototype.toString.call(true) // "[object Boolean]"
Object.prototype.toString.call(undefined) // "[object Undefined]"
Object.prototype.toString.call(null) // "[object Null]"
Object.prototype.toString.call(Math) // "[object Math]"
Object.prototype.toString.call({}) // "[object Object]"
Object.prototype.toString.call([]) // "[object Array]"
Object.prototype.toString.call(/\d/) // "[object RegExp]"
Object.prototype.toString.call(Array.isArray) // "[object Function]"
```

### isObject

```js
// Object 方法的参数是一个对象，它总是返回该对象，即不用转换。
function isObject(value) {
	return value === Object(value)
}
```

### isEmptyObject

```js
function isEmptyObject(obj) {
	if (typeof obj !== 'object' || obj === null) return false
	return Object.keys(obj).length === 0 ? true : false
}

console.log(isEmptyObject({})) // true
console.log(isEmptyObject([])) // true 空数组算空对象吗？
```

### isInteger

```js
// 整数取整还是整数
function isInteger(num) {
	return typeof num === 'number' && (num | 0) === num ? true : false
}

console.log(isInteger(1)) // true
console.log(isInteger(1.1)) // false
```

### isPromise

```js

```

### isPrime

```js
// 素数只能被自己和 1 整除不含 1 , 2 是素数
// 判断素数只要判断到开方就行，false 跳出条件是 num % i === 0

function isPrime(num) {
	if (typeof num === 'number' && (num | 0) === num) {
		if (num <= 1) return false
		const N = Math.floor(Math.sqrt(num))
		let primeState = true
		for (let i = 2; i <= N; i++) {
			if (num % i === 0) {
				primeState = false
				break
			}
		}
		return primeState
	} else {
		return false
	}
}

console.log(isPrime(2)) // true
console.log(isPrime(87)) // false
console.log(isPrime(77)) // false
```

### `Object.is()` / `Array.isArray()` / `Number.isInteger()` / `isNaN()` / `Number.isNaN()`

```js
console.log(Object.is(+0, -0)) // false
console.log(Object.is(NaN, NaN)) // true

console.log(Array.isArray([])) // true
console.log(Array.isArray({})) // false

console.log(Number.isInteger('1')) // false
console.log(Number.isInteger(1)) //true

console.log(Number.isNaN(NaN)) // true
console.log(isNaN(NaN)) // true

console.log(isNaN({})) // true 隐式类型转换
console.log(Number.isNaN({})) // false
```

## 作用域, 调用堆栈, 闭包

> TIP
>
> 红宝书(p178)上对于闭包的定义：**闭包是指有权访问另外一个函数作用域中的变量的函数**

> TIP

> 作用域链：在 ES5 中只存在两种作用域————全局作用域和函数作用域，`当访问一个变量时，解释器会首先在当前作用域查找标示符，如果没有找到，就去父作用域找，直到找到该变量的标示符或者不在父作用域中，这就是作用域链`，值得注意的是，每一个子函数都会拷贝上级的作用域，形成一个作用域的链条。

### 闭包产生的原因 ?

> 红宝书(p73)上对于函数执行的阐述：

> 每次调用函数时都会创建一个全新的**函数执行环境对象**，这个就是调用栈上的对象。**初始化执行环境时会创建一个变量对象，然后初始化这个变量对象，最后确定 this 指向。每个函数调用都有一个自己的 this**。

> **变量对象/函数活动对象也是在函数调用时动态创建的，它不在调用栈上（不考虑解释器优化），它是单独分配创建的，函数里的局部变量以及参数都保存在这个变量对象中。**
>
> 执行环境包含一个作用域链属性，在创建执行环境时，它把函数对象自身的作用域链属性复制过来，然后将本次调用的变量对象添加到作用域链顶端，这就形成了本次调用的作用域链。函数中的名字查找都是沿着这条作用域链进行的。注意，函数对象的作用域链是在函数对象创建时创建的，和执行环境的作用域链不是一回事。
>
> **函数对象创建时，直接将外层执行环境对象的作用域链复制为自己的作用域链。这也说明了，js 函数是静态词法作用域。**
>
> **虽然外层函数执行完毕了，执行环境对象也出栈了，但是变量对象仍然被内嵌函数对象的作用域链所引用，它不会被回收**。好了，现在就可以明白了为什么内嵌函数能够直接访问外层函数的变量了。内嵌函数的作用域链中引用着外层函数执行时的变量对象。然后，这个作用域链被复制到内嵌函数的执行环境对象上，在内嵌函数中查找变量就会查到外层函数调用时的变量对象上。**这也能说明为什么内嵌函数访问的是外层变量最后的值，不是创建内嵌函数时外层变量当时的值。**

我的理解：

1. `内嵌函数执行时访问变量是沿着函数定义时的作用域链访问的。`
2. `外层函数执行完弹出调用栈后，内层函数仍可保持对外层函数局部变量或参数的引用，局部变量或参数的引用不会被垃圾回收，除非被重新声明。`
3. `内嵌函数访问的是外层变量最后的值，不是创建内嵌函数时外层变量当时的值。`
4. `函数执行时会确定 this 指向。`

```js
function f1() {
	let a = 2
	return function f2() {
		console.log(a++)
	}
}

const f = f1()
f() // 2
f() // 3
f() // 4

f1()() // 2
f1()() // 2
```

**闭包产生的本质就是，当前环境中存在指向父级作用域的引用。**

- 这里 f2 会通过函数定义时的作用域链拿到父级作用域 f1 中的变量 a，这里就产生了闭包，所以除非 a 被重新声明，否则 a 会一直在内存中，不会被垃圾回收
- `const f = f1(2)`这段代码执行时，f1 入栈，并将 f1 中的变量 a 赋值为 2，并且将 f2 返回赋值给 f，f1 出栈
- f 执行时，f2 入栈，输出 2，并将 f1 中的变量 a 计算为 3，f2 出栈
- f 再次执行时，f2 入栈，此时 a 的值已经变为 3，输出 3，并将 f1 中的变量 a 计算为 4，f2 出栈
- f 最后执行时，f2 入栈，此时 a 的值已经变为 4，输出 4，并将 f1 中的变量 a 计算为 5，f2 出栈
- `f1()()` 执行时，a 变量被重新声明，所以输出 2

### 那是不是只有返回函数才算是产生了闭包呢？、

回到闭包的本质，我们只需要让父级作用域的引用存在即可，因此我们还可以这么做：

```js
let x = 0,
	y = 1
function fn() {
	x += 2
	fn = function (y) {
		console.log(y + --x)
	}
	console.log(x, y)
}
fn(3) // 2, 1
fn(4) // 5
```

- fn 第一次执行，计算 x 的值为 2 给 fn 重新赋值新的函数，输出 x 为 2，y 为上层作用域的 1
- fn 第二次执行，x 为上层作用域的 2，y 为传入的 4，经过计算，输出 5

在这里是内层的 fn 函数存在着父级作用域的引用，因此产生了闭包，形式变了，本质没有改变。

### 闭包的应用

```js
// a[6]定义时在全局作用域下，执行时根据作用域链去寻找寻找上层变量，全局变量 i，全局变量 i 在循环结束时已经是 10 了，所以返回 10
var a = []
for (var i = 0; i < 10; i++) {
	a[i] = function () {
		console.log(i)
	}
}
a[6]() // 10
```

```js
// 为了解决上面的问题，我们只需要运用闭包的思想，把每一次循环的变量 i 都保存起来即可
var c = []
for (var i = 0; i < 10; i++) {
	c[i] = (function (i) {
		return function () {
			console.log(i)
		}
	})(i)
}
c[6]() // 6
```

```js
// b[6]定义时在块级作用域下，执行时根据作用域链去寻找寻找上层变量，块级变量 i，块级变量 i 每一次循环都是一个新的变量，所以返回 6
var b = []
for (let i = 0; i < 10; i++) {
	b[i] = function () {
		console.log(i)
	}
}
b[6]() // 6
```

## 原型与原型链

```

```

## this, call, apply 和 bind

## 异步编程
